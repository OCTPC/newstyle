#テスト

require 'json'
require 'uri'
require 'net/http'
require 'pp'
require 'natto'
require 'matrix' 

#文字列を分析してハッシュを返す
def mecab(str)
info = {}
nm = Natto::MeCab.new
nm.parse(str)do |n|
	info[n.surface] = []
  n.feature.split(",").each{|i| 
  i== "*" ? break : info[n.surface] << i}
end
info.delete("")
return  info
end

#引数から名詞以外のものを取り除く
def delkey(hash)
	del = []
	hash.each do|key,val|
	s = val.size-1;c=0
	val.each{|i|
	if i =="名詞" then break
	elsif c==s then del << key
	end 	
	c =c+1
	}
	end
	del.each{|i| hash.delete(i)}
	return hash
end

#ハッシュからリスト作成
def mklist(*hash)
	list = []
	hash.each{|i|
		i.each_key{|k|
		flag=0
			list.each{|j|
				flag = 1 if j==k 
			}
			list << k if flag==0
		}
	}
	return list;
end

#文字列の配列からリスト作成
def mklisa(str)	
hash = []
	str.each{|i|
		hash << delkey(mecab(i))
	}
	
	list = []
	hash.each{|i|
		i.each_key{|k|
		flag=0
			list.each{|j|
				flag = 1 if j==k 
			}
			list << k if flag==0
		}
	}
	return list;
end

#複数の文字列からリスト作成
def mklis(*str)	
hash = []
	str.each{|i|
		hash << delkey(mecab(i))
	}
	
	list = []
	hash.each{|i|
		i.each_key{|k|
		flag=0
			list.each{|j|
				flag = 1 if j==k 
			}
			list << k if flag==0
		}
	}
	return list;
end

#リストを元に文字列をベクトル化
def mkvec(list,str)
	pstr = []
	nm = Natto::MeCab.new
	nm.parse(str)do |n|
	pstr << n.surface
	end
	
	vec = []
	list.each{|i|
	count=0
		pstr.each{|k|
			count = count+1 if k==i
		}
	vec << count
	}
	return vec
end

#maxをもとにスコアをだす
def score(max,vec)
	max = Vector.elements(max)
	vec= Vector.elements(vec)
	return max.inner_product(vec)
end

#ベクトルから類似度を出す
def comp(max,*vec)
	vec = vec[0] if vec[0].class==Array
	result = []
	count=0
	basis = score(max,max).to_f
	vec.each{|i|
		s= score(max,i).to_f / basis
		result << {score: s,num: count}
		count = count+1
	}
	return result.sort!{|a,b|b[:score] <=> a[:score]}
end

#最初の引数を基準に文字列の類似度をだす(引数は文字列を区切るか文字列の配列)
def alcomp(*str)
	ｓｔｒ = str[0] if str[0].class == Array
	list = mklisa(str)
	count=0
	str.each{|i|
		str[count] = mkvec(list,i)
		count = count+1
	}
	max = str.shift
	return comp(max,str)
end
